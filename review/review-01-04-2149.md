변경 반영된 상태 기준으로 다시 보면, 이전에 짚었던 “인덱스 생성/튜닝 미호출”, “컬렉션 조인 비용”, “본문 조회 I/O” 이슈는
  해소된 것으로 보입니다. (api/use_cases/ingest.py, retrieval/search.py)                                                  
                                                                                                                          
  그럼에도 검색 성능과 직접 연관된 잠재 이슈는 남아 있습니다:                                                             
                                                                                                                          
  - VectorSearchEngine/ContextExpander가 매 요청마다 신규 DB 연결을 엽니다. 고빈도 검색에서는 커넥션 오버헤드가 지연의 주 
    요 원인이 될 수 있습니다. retrieval/search.py, retrieval/context.py
  - apply_db_level_tuning()이 검색 엔진 초기화 시마다 ALTER DATABASE ...를 실행합니다. 권한 부족 시 경고 로그, 권한이 있어    도 불필요한 DDL 호출로 지연/락 가능성이 있습니다. retrieval/search.py, storage/schema.py                              
  - ensure_indexes()가 컬렉션명별로 같은 전체 테이블 인덱스를 생성합니다. 다중 컬렉션 운영 시 중복 인덱스가 누적되어 쓰기/
    유지 비용이 증가하고, 검색에서도 캐시/메모리 효율이 떨어질 수 있습니다. storage/schema.py                             
  - langchain_pg_embedding.collection_id 또는 langchain_pg_collection.name 인덱스가 DB 스키마에 없으면 컬렉션 필터링이 느 
    려질 수 있습니다(기본 스키마 의존). retrieval/search.py                                                               
                                                                                                                          
  필요하면 다음 중에서 확인/개선 방향을 제안할 수 있어요:                                                                 
                                                                                                                          
  1. 커넥션 풀 도입 또는 장기 연결 재사용                                                                                 
  2. DB 튜닝 적용을 프로세스 시작 시 1회로 이동                                                                           
  3. 컬렉션별 partial index 전략으로 중복 인덱스 제거                                                                     
  4. 실제 DB에서 EXPLAIN ANALYZE로 HNSW/필터 인덱스 사용 여부 확인